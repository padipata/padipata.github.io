<!doctype html>
<html>
<head>
    <base href="/">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="author" content="padipata">

<meta name="description" content="">

<title>padipata blog</title>
<meta name="generator" content="Hugo 0.55.6" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/styles/pojoaque.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.1.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" rel="stylesheet" type="text/css">
<link  href="https://padipata.github.io//css/theme.min.css" rel="stylesheet" type="text/css">

</head>
<body>
<div class="page-container container-fluid">
<div class="col-md-3 menu">
    <nav class="col-md-3">
    
    <h3 class="home-link"><a href="https://padipata.github.io/">Root</a></h3>
    <div id="last-posts" class="open">
        <h3 data-open="last-posts">padipata blog - Most recent posts</h3>
        <ul>
            
            <li><a href="https://padipata.github.io/mysql/mycat/">mysql&#43;mycat搭建高可用集群，负载均衡，主从复制，读写分类</a></li>
            
            <li><a href="https://padipata.github.io/net/https/">https介绍及中间人攻击</a></li>
            
            <li><a href="https://padipata.github.io/vue/yinanzazheng/">vue疑难杂症</a></li>
            
            <li><a href="https://padipata.github.io/javascript/kaobei/">谈谈JavaScript的深浅拷贝</a></li>
            
        </ul>
    </div>
    

    

    
</nav>

</div>
<div class="col-md-9 content">


<div class="articles-list">
    
    <article>
        <h3><a href="https://padipata.github.io/javascript/kaobei/">谈谈JavaScript的深浅拷贝</a> - 2019-07-05 14:39:14</h3>
        为什么要进行拷贝 var obj1={ value: 'a' } var obj2 = obj1; obj2.value='b'; console.log(obj1);//{ value: 'b' }  因为对象是引用类型，所以赋值时的操作仅是赋予相同的地址，当对其中一个对象进行操作时，就会影响其他的对象。解决这个问题就需要拷贝了。
浅拷贝： 使用原生的 Object.assign() 方法就可以实现浅拷贝
var obj1={ value: 'a' } var obj2 = Object.assign({},obj1); obj2.value='b'; console.log(obj1);//{ value: 'a' }  但是如果拷贝的源对象当中包含对象时，OBject.assign()方法只会拷贝对象的引用地址
var obj1={ value: 'a', obj3:{ value2: 'c' } } var obj2 = Object.assign({},obj1); obj2.obj3.value2='b'; console.log(obj1);//{ value: 'a', obj3:{ value2: 'b' } }  深拷贝 如果要拷贝的对象中包含对象，就需要深拷贝了，一般使用原生的方法JSON.parse(JSON.stringify(obj))
j1={ value: 'a', obj3:{ value2: 'c' }, arr:[1,2,3] } var obj2 = JSON.
    </article>
    
    <article>
        <h3><a href="https://padipata.github.io/vue/yinanzazheng/">vue疑难杂症</a> - 2019-07-05 16:35:33</h3>
        vue首页白屏（几率性） // 在config文件夹中找到index.js打开把 assetsPublicPath: '/' // 改成 assetsPublicPath: './' // 再次执行 npm run build 就可以了。  消除transition闪屏 .css { -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden; -webkit-perspective: 1000; }  history模式下404 // 服务器的404页面需要重定向到index.html(nginx) try_files $uri $uri/ /index.html;  解决vue打包vendor过大  在webpack.base.conf.js新增externals配置，表示不需要打包的文件，然后在index.html中通过CDN引入  externals: { &quot;vue&quot;: &quot;Vue&quot;, &quot;vue-router&quot;: &quot;VueRouter&quot;, &quot;vuex&quot;: &quot;Vuex&quot;, &quot;element-ui&quot;: &quot;ELEMENT&quot;, &quot;BMap&quot;: &quot;BMap&quot; }  2、使用路由懒加载
网站被劫持植入广告  https，最稳
 在网站页头加入如下代码：
&lt;style&gt; html{display : none ; } &lt;/style&gt; &lt;script&gt; if( self == top ) { document.
    </article>
    
    <article>
        <h3><a href="https://padipata.github.io/net/https/">https介绍及中间人攻击</a> - 2019-07-09 21:55:01</h3>
         SSL或TLS握手的概述 SSL或TLS握手建立了用于客户端和服务端通信的秘钥。
客户端和服务端SSL或TLS能够相互通信的基本步骤：
 确认使用协议的版本 选择加密算法 通过交换和验证数字证书对彼此进行身份验证 使用非对称加密技术生成共享密钥，避免了密钥分发问题。然后SSL或TLS使用共享密钥对消息进行对称加密解密，这比非对称加密更快  综上所述SSL握手的步骤如下：
 SSL或TLS客户端先向服务端发送一个加密通信请求，叫做ClientHello请求。该请求包含以下信息：  客户端支持的SSL或者TLS版本 客户端生成的随机数，用于生成后续通信的随机字符串（&rdquo;对话密钥&rdquo;） 客户端支持的加密算法  SSL或TLS服务端收到客户端请求后，向客户端发出响应，叫做ServerHello。该响应包含以下信息：  服务端从客户端提供的SSL或TLS列表中选择的版本 Sesstion ID 和 另外生成的随机数 服务端的数字证书（如果服务端需要用于客户端身份验证的数字证书，则服务端发送一个客户端证书请求，其中包含受支持的证书类型列表和可接受的认证机构(CAs)的专有名称。） 确认使用的加密算法  客户端收到服务端响应后，首先校验服务端发来的数字证书决定是否继续通信。 证书校验通过，会像服务端发送以下信息：  生成一个随机数，并对这个随机数用从服务端数字证书中取出的公钥加密（用与生成后续通信的“随机密钥”）  如果服务端发送了一个客户端证书请求，客户端将会发送一个用客户端私钥加密的随机字符串和客户端的数字证书，或者没有数字证书的警告。在某些强制客户端证书的实现中，如果客户端没有数字证书责握手会失败 服务端接受并验证客户端证书 客户端向服务端发送一条完成的消息，该消息使用密钥加密，表示握手的客户端部分已经完成。 服务端向客户端发送一条完成的消息，该消息使用密钥加密，表示握手的服务端部分已经完成 在SSL或TLS会话期间，服务端和客户端现在可以交换使用共享密钥对称加密的消息  中间人攻击 中间人攻击过程如下：
 服务器向客户端发送公钥。 攻击者截获公钥，保留在自己手上。 然后攻击者自己生成一个【伪造的】公钥，发给客户端。 客户端收到伪造的公钥后，生成加密hash值发给服务器。 攻击者获得加密hash值，用自己的私钥解密获得真秘钥。 同时生成假的加密hash值，发给服务器。 服务器用私钥解密获得假秘钥。 服务器用加秘钥加密传输信息  防范方法：
 服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性  
    </article>
    
    <article>
        <h3><a href="https://padipata.github.io/mysql/mycat/">mysql&#43;mycat搭建高可用集群，负载均衡，主从复制，读写分类</a> - 2019-07-11 17:33:35</h3>
        工具准备  mysql两台（版本推荐5.5以上）：  A主mysql：192.168.10.1:3306, 用户root，密码123456 B备mysql：192.168.10.2:3306, 用户root，密码123456    AB两台服务器中的mysql都创建sync_test数据库
 实现mysql主备复制  主要思路：A开启日志，B读取操作日志，同步执行。
 配置A主mysql  在mysql安装目录下创建目录和文件mysql/log/mysql-bin.log
 修改my.ini
[mysqld] server-id=1 #主机标示，整数 port=3306 log-bin=&quot;xxx/mysql/log/mysql-bin.log&quot; #确保此文件可写 read-only=0 #主机，读写都可以 binlog-do-db=sync_test #需要备份数据库，多个写多行 binlog-ignore-db=mysql #不需要备份的数据库，多个写多行  允许mysql远程访问(lnmp服务器需要去掉防火墙)
mysql -uroot -proot mysql&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'192.168.10.*' IDENTIFIED BY 'root' WITH GRANT OPTION; mysql&gt;FLUSH PRIVILEGES;  重启A主mysql数据库
  配置B备mysql  在mysql安装目录下创建目录和文件mysql/log/mysql-bin.log
 修改my.ini
[mysqld] # add for sycn test server-id=2 #从机标识 log-bin=&quot;xxx/mysql/log/mysql-bin.
    </article>
    
</div>


</div>
</div>
<script src="https://padipata.github.io//js/theme.min.js" type="text/javascript"></script>


</body>
</html>

